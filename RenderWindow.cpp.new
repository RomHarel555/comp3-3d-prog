#include "RenderWindow.h"
#include <QVulkanFunctions>
#include <QFile>
#include "VulkanWindow.h"

// ENLARGED ground vertex data (10x10 plane instead of 5x5)
static float groundVertexData[] = {
    -10.0f,  0.0f, -10.0f,   0.3f, 0.3f, 0.3f,  // Bottom-left
    -10.0f,  0.0f,  10.0f,   0.3f, 0.3f, 0.3f,  // Top-left
     10.0f,  0.0f, -10.0f,   0.3f, 0.3f, 0.3f,  // Bottom-right

    -10.0f,  0.0f,  10.0f,   0.3f, 0.3f, 0.3f,  // Top-left
     10.0f,  0.0f,  10.0f,   0.3f, 0.3f, 0.3f,  // Top-right
     10.0f,  0.0f, -10.0f,   0.3f, 0.3f, 0.3f   // Bottom-right
};

// FIXED Player cube vertex data (MUCH brighter blue color for visibility)
static float playerVertexData[] = {
    // Front face
    -0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  // Bright blue
     0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  

    // Back face
    -0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  

    // Left face
    -0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f, 

    // Right face
     0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  

    // Top face
    -0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f,  0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f,  0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  

    // Bottom face
    -0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
    -0.8f, -0.8f,  0.8f,   0.0f, 0.0f, 1.0f,  
     0.8f, -0.8f, -0.8f,   0.0f, 0.0f, 1.0f    
};

// FIXED Collectible vertex data (VERY bright yellow color)
static float collectibleVertexData[] = {
    // Front face (pure bright yellow)
    -0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  // Pure yellow
     0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  

    // Back face
    -0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  

    // Left face
    -0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  

    // Right face
     0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  

    // Top face
    -0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f,  0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f,  0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  

    // Bottom face
    -0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.6f, -0.6f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.6f, -0.6f, -0.6f,   1.0f, 1.0f, 0.0f   
};

// NPC vertex data arrays with different colors for each NPC
// Red NPC vertex data (for NPC 1)
static float npcVertexData1[] = {
    // Front face (bright red color)
    -0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  // Pure red
     0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  

    // Back face
    -0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  

    // Left face
    -0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  

    // Right face
     0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  

    // Top face
    -0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  

    // Bottom face
    -0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   1.0f, 0.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   1.0f, 0.0f, 0.0f   
};

// Green NPC vertex data (for NPC 2)
static float npcVertexData2[] = {
    // Front face (bright green color)
    -0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  // Pure green
     0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  

    // Back face
    -0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  

    // Left face
    -0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  

    // Right face
     0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  

    // Top face
    -0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  

    // Bottom face
    -0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 1.0f, 0.0f,  
    -0.7f, -0.7f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.7f, -0.7f,  0.6f,   1.0f, 1.0f, 0.0f,  
    -0.7f, -0.7f,  0.6f,   1.0f, 1.0f, 0.0f,  
     0.7f, -0.7f, -0.6f,   1.0f, 1.0f, 0.0f   
};

// Blue NPC vertex data (for NPC 3)
static float npcVertexData3[] = {
    // Front face (bright blue color)
    -0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  // Bright blue
     0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  

    // Back face
    -0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  

    // Left face
    -0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  

    // Right face
     0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  

    // Top face
    -0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f,  0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f,  0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  

    // Bottom face
    -0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
    -0.7f, -0.7f,  0.7f,   0.0f, 0.5f, 1.0f,  
     0.7f, -0.7f, -0.7f,   0.0f, 0.5f, 1.0f   
};

//House vertex data - brown walls
static float houseWallsVertexData[] = {
    // Front wall (with door hole)
    // Left part of front wall
    -3.0f,  0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-left
    -3.0f,  2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left
    -1.0f,  0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    -1.0f,  2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-right
    -1.0f,  0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    -3.0f,  2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left

    // Right part of front wall
    1.0f,   0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-left
    1.0f,   2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left
    3.0f,   0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    3.0f,   2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-right
    3.0f,   0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    1.0f,   2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left

    // Top part of front wall
    -1.0f,  2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-left
    -1.0f,  3.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left
    1.0f,   2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    1.0f,   3.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-right
    1.0f,   2.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    -1.0f,  3.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-left

    // Back wall
    -3.0f,  0.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-left
    -3.0f,  3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-left
    3.0f,   0.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    3.0f,   3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-right
    3.0f,   0.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-right
    -3.0f,  3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-left

    // Left wall
    -3.0f,  0.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-back
    -3.0f,  3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-back
    -3.0f,  0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-front
    -3.0f,  3.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-front
    -3.0f,  0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-front
    -3.0f,  3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-back

    // Right wall
    3.0f,   0.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-back
    3.0f,   3.0f, -3.0f,   0.6f, 0.4f, 0.2f,  // Top-back
    3.0f,   0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-front
    3.0f,   3.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Top-front
    3.0f,   0.0f,  3.0f,   0.6f, 0.4f, 0.2f,  // Bottom-front
    3.0f,   3.0f, -3.0f,   0.6f, 0.4f, 0.2f   // Top-back
};

// House door vertex data - dark brown (closed position)
static float houseDoorVertexData[] = {
    // Door (slightly inset)
    -1.0f,  0.0f,  2.9f,   0.4f, 0.2f, 0.1f,  // Bottom-left
    -1.0f,  2.0f,  2.9f,   0.4f, 0.2f, 0.1f,  // Top-left
    1.0f,   0.0f,  2.9f,   0.4f, 0.2f, 0.1f,  // Bottom-right
    1.0f,   2.0f,  2.9f,   0.4f, 0.2f, 0.1f,  // Top-right
    1.0f,   0.0f,  2.9f,   0.4f, 0.2f, 0.1f,  // Bottom-right
    -1.0f,  2.0f,  2.9f,   0.4f, 0.2f, 0.1f   // Top-left
};

// House door vertex data - dark brown (open position - rotated 90 degrees)
static float houseDoorOpenVertexData[] = {
    // Door (rotated to open position) - with a different color to make it obvious when open
    -1.0f,  0.0f,  2.9f,   0.9f, 0.5f, 0.2f,  // Bottom-left (hinge point) - brighter color
    -1.0f,  2.0f,  2.9f,   0.9f, 0.5f, 0.2f,  // Top-left (hinge point) - brighter color
    -1.0f,  0.0f,  0.9f,   0.9f, 0.5f, 0.2f,  // Bottom-right (new position) - brighter color
    -1.0f,  2.0f,  0.9f,   0.9f, 0.5f, 0.2f,  // Top-right (new position) - brighter color
    -1.0f,  0.0f,  0.9f,   0.9f, 0.5f, 0.2f,  // Bottom-right (new position) - brighter color
    -1.0f,  2.0f,  2.9f,   0.9f, 0.5f, 0.2f   // Top-left (hinge point) - brighter color
};

// House roof vertex data - red
static float houseRoofVertexData[] = {
    // Front triangle
    -3.5f,  3.0f,  3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-left
    3.5f,   3.0f,  3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-right
    0.0f,   5.0f,  0.0f,   0.8f, 0.2f, 0.2f,  // Top

    // Back triangle
    -3.5f,  3.0f, -3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-left
    3.5f,   3.0f, -3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-right
    0.0f,   5.0f,  0.0f,   0.8f, 0.2f, 0.2f,  // Top

    // Left triangle
    -3.5f,  3.0f, -3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-back
    -3.5f,  3.0f,  3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-front
    0.0f,   5.0f,  0.0f,   0.8f, 0.2f, 0.2f,  // Top

    // Right triangle
    3.5f,   3.0f, -3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-back
    3.5f,   3.0f,  3.5f,   0.8f, 0.2f, 0.2f,  // Bottom-front
    0.0f,   5.0f,  0.0f,   0.8f, 0.2f, 0.2f   // Top
};

// Indoor walls vertex data - light beige
static float indoorWallsVertexData[] = {
    // Front wall (with door hole)
    // Left part of front wall
    -3.0f,  0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-left
    -3.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left
    -1.0f,  0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    -1.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-right
    -1.0f,  0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    -3.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left

    // Right part of front wall
    1.0f,   0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-left
    1.0f,   3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left
    3.0f,   0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    3.0f,   3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-right
    3.0f,   0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    1.0f,   3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left

    // Top part of front wall
    -1.0f,  2.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-left
    -1.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left
    1.0f,   2.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    1.0f,   3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-right
    1.0f,   2.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    -1.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-left

    // Back wall
    -3.0f,  0.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-left
    -3.0f,  3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-left
    3.0f,   0.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    3.0f,   3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-right
    3.0f,   0.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-right
    -3.0f,  3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-left

    // Left wall
    -3.0f,  0.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-back
    -3.0f,  3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-back
    -3.0f,  0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-front
    -3.0f,  3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-front
    -3.0f,  0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-front
    -3.0f,  3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-back

    // Right wall
    3.0f,   0.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-back
    3.0f,   3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-back
    3.0f,   0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-front
    3.0f,   3.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Top-front
    3.0f,   0.0f,  3.0f,   0.9f, 0.8f, 0.7f,  // Bottom-front
    3.0f,   3.0f, -3.0f,   0.9f, 0.8f, 0.7f,  // Top-back
    
    // Ceiling
    -3.0f,  3.0f, -3.0f,   0.9f, 0.9f, 0.8f,  // Back-left
    3.0f,   3.0f, -3.0f,   0.9f, 0.9f, 0.8f,  // Back-right
    -3.0f,  3.0f,  3.0f,   0.9f, 0.9f, 0.8f,  // Front-left
    3.0f,   3.0f,  3.0f,   0.9f, 0.9f, 0.8f,  // Front-right
    -3.0f,  3.0f,  3.0f,   0.9f, 0.9f, 0.8f,  // Front-left
    3.0f,   3.0f, -3.0f,   0.9f, 0.9f, 0.8f,  // Back-right
    
    // Floor
    -3.0f,  0.0f, -3.0f,   0.7f, 0.6f, 0.5f,  // Back-left
    3.0f,   0.0f, -3.0f,   0.7f, 0.6f, 0.5f,  // Back-right
    -3.0f,  0.0f,  3.0f,   0.7f, 0.6f, 0.5f,  // Front-left
    3.0f,   0.0f,  3.0f,   0.7f, 0.6f, 0.5f,  // Front-right
    -3.0f,  0.0f,  3.0f,   0.7f, 0.6f, 0.5f,  // Front-left
    3.0f,   0.0f, -3.0f,   0.7f, 0.6f, 0.5f,  // Back-right
};

// Exit door vertex data (for inside)
static float exitDoorVertexData[] = {
    // Door (exit to outside)
    -1.0f,  0.0f,  3.0f,   0.4f, 0.8f, 0.4f,  // Bottom-left (green for exit)
    -1.0f,  2.0f,  3.0f,   0.4f, 0.8f, 0.4f,  // Top-left
    1.0f,   0.0f,  3.0f,   0.4f, 0.8f, 0.4f,  // Bottom-right
    1.0f,   2.0f,  3.0f,   0.4f, 0.8f, 0.4f,  // Top-right
    1.0f,   0.0f,  3.0f,   0.4f, 0.8f, 0.4f,  // Bottom-right
    -1.0f,  2.0f,  3.0f,   0.4f, 0.8f, 0.4f   // Top-left
};

//Utility variable and function for alignment:
static const int UNIFORM_DATA_SIZE = 16 * sizeof(float); //our MVP matrix contains 16 floats

// Forward declarations
static uint32_t getMemoryTypeIndex(const VkPhysicalDeviceMemoryProperties& memProperties, 
                                 uint32_t typeBits, 
                                 VkMemoryPropertyFlags properties);

// Helper functions
static inline VkDeviceSize aligned(VkDeviceSize v, VkDeviceSize byteAlign)
{
    return (v + byteAlign - 1) & ~(byteAlign - 1);
}

/*** RenderWindow class ***/

RenderWindow::RenderWindow(QVulkanWindow *w, bool msaa)
    : mWindow(w),
    mPlayerPosition(0.0f, 0.0f, 0.0f),      // Player starts at center of platform
    mGameManager(nullptr),                   // Initialize to nullptr first
    mCollectedCount(0)                       // Initialize collected count
{
    if (msaa) {
        const QList<int> counts = w->supportedSampleCounts();
        qDebug() << "Supported sample counts:" << counts;
        for (int s = 16; s >= 4; s /= 2) {
            if (counts.contains(s)) {
                qDebug("Requesting sample count %d", s);
                w->setSampleCount(s);
                break;
            }
        }
    }
    
    // Initialize GameManager after member initialization
    mGameManager = new GameManager(this);
    
    // Initialize player position
    mPlayerPosition = QVector3D(0.0f, 0.0f, 0.0f);
    
    // Initialize collectibles
    initializeCollectibles();
    
    // Initialize NPCs
    initializeNPCs();
    
    // Debug initial setup
    qDebug() << "Initial player position:" << mPlayerPosition;
}

RenderWindow::~RenderWindow()
{
    delete mGameManager;
}

void RenderWindow::moveForward(float distance)
{
    // Store old position for debug output
    QVector3D oldPos = mPlayerPosition;
    
    // Move player along negative Z axis (forward in top-down view)
    // Multiply distance by 5 for faster movement
    mPlayerPosition.setZ(mPlayerPosition.z() - (distance * 5.0f));
    
    // Keep player on ground
    mPlayerPosition.setY(0.0f);
    
    qDebug() << "Moving player cube from" << oldPos << "to" << mPlayerPosition;
    
    // Request a redraw to show the player in its new position
    if (mWindow) {
        mWindow->requestUpdate();
    }
}

void RenderWindow::moveRight(float distance)
{
    // Store old position for debug output
    QVector3D oldPos = mPlayerPosition;
    
    // Move player along positive X axis (right in top-down view)
    // Multiply distance by 5 for faster movement
    mPlayerPosition.setX(mPlayerPosition.x() + (distance * 5.0f));
    
    // Keep player on ground
    mPlayerPosition.setY(0.0f);
    
    qDebug() << "Moving player cube from" << oldPos << "to" << mPlayerPosition;
    
    // Request a redraw to show the player in its new position
    if (mWindow) {
        mWindow->requestUpdate();
    }
}

void RenderWindow::moveCube(const QVector3D& movement)
{
    // Store old position for debug output
    QVector3D oldPos = mPlayerPosition;

    // Apply direct movement - make sure input controls are properly applied
    mPlayerPosition.setX(mPlayerPosition.x() + movement.x());
    mPlayerPosition.setZ(mPlayerPosition.z() + movement.z());
    
    // Keep within ground boundaries
    const float BOUNDARY = 9.5f; // Slightly smaller than the ground plane size
    mPlayerPosition.setX(qBound(-BOUNDARY, mPlayerPosition.x(), BOUNDARY));
    mPlayerPosition.setZ(qBound(-BOUNDARY, mPlayerPosition.z(), BOUNDARY));
    
    // Force Y to be 0 to keep player on ground
    mPlayerPosition.setY(0.0f);

    qDebug() << "PLAYER MOVED: From" << oldPos << "to" << mPlayerPosition 
             << "- Applied movement:" << movement;
             
    // Check for collectible collisions after movement
    checkCollectibleCollisions();

    // Request a redraw to update the scene
    if (mWindow) {
        mWindow->requestUpdate();
    }
}

void RenderWindow::rotate(float yawDelta, float pitchDelta)
{
    // Ignore rotation since we're using a fixed top-down view
    Q_UNUSED(yawDelta);
    Q_UNUSED(pitchDelta);
}

void RenderWindow::initResources()
{
    qDebug("\n ***************************** initResources ******************************************* \n");

    VkDevice logicalDevice = mWindow->device();
    mDeviceFunctions = mWindow->vulkanInstance()->deviceFunctions(logicalDevice);

    const int concurrentFrameCount = mWindow->concurrentFrameCount(); // 2 on Oles Machine
    const VkPhysicalDeviceLimits *pdevLimits = &mWindow->physicalDeviceProperties()->limits;
    const VkDeviceSize uniAlign = pdevLimits->minUniformBufferOffsetAlignment;
    qDebug("uniform buffer offset alignment is %u", (uint)uniAlign); //64 on Oles machine

    // Create uniform buffer for MVP matrices - allocate 8x the size to include indoor scene
    VkBufferCreateInfo bufInfo;
    memset(&bufInfo, 0, sizeof(bufInfo));
    bufInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
    // Increased size to accommodate ground, player, collectibles, 3 separate NPCs, house, and indoor scene
    bufInfo.size = concurrentFrameCount * 8 * aligned(UNIFORM_DATA_SIZE, uniAlign);
    bufInfo.usage = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;

    // Use existing err variable
    VkResult err = mDeviceFunctions->vkCreateBuffer(logicalDevice, &bufInfo, nullptr, &mBuffer);
    if (err != VK_SUCCESS)
        qFatal("Failed to create uniform buffer: %d", err);

    VkMemoryRequirements memReq;
    mDeviceFunctions->vkGetBufferMemoryRequirements(logicalDevice, mBuffer, &memReq);

    VkMemoryAllocateInfo memAllocInfo = {
        VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        nullptr,
        memReq.size,
        mWindow->hostVisibleMemoryIndex()
    };

    err = mDeviceFunctions->vkAllocateMemory(logicalDevice, &memAllocInfo, nullptr, &mBufferMemory);
    if (err != VK_SUCCESS)
        qFatal("Failed to allocate memory: %d", err);

    err = mDeviceFunctions->vkBindBufferMemory(logicalDevice, mBuffer, mBufferMemory, 0);
    if (err != VK_SUCCESS)
        qFatal("Failed to bind buffer memory: %d", err);

    // Setup uniform buffer descriptors
    quint8 *p;
    err = mDeviceFunctions->vkMapMemory(logicalDevice, mBufferMemory, 0, memReq.size, 0, reinterpret_cast<void **>(&p));
    if (err != VK_SUCCESS)
        qFatal("Failed to map memory: %d", err);

    QMatrix4x4 ident;
    memset(mUniformBufferInfo, 0, sizeof(mUniformBufferInfo));
    memset(mPlayerUniformBufferInfo, 0, sizeof(mPlayerUniformBufferInfo));
    memset(mCollectibleUniformBufferInfo, 0, sizeof(mCollectibleUniformBufferInfo));
    memset(mNPCUniformBufferInfo1, 0, sizeof(mNPCUniformBufferInfo1));
    memset(mNPCUniformBufferInfo2, 0, sizeof(mNPCUniformBufferInfo2));
    memset(mNPCUniformBufferInfo3, 0, sizeof(mNPCUniformBufferInfo3));
    memset(mHouseUniformBufferInfo, 0, sizeof(mHouseUniformBufferInfo));
    memset(mIndoorUniformBufferInfo, 0, sizeof(mIndoorUniformBufferInfo));
    
    const VkDeviceSize alignedUniformSize = aligned(UNIFORM_DATA_SIZE, uniAlign);
    
    for (int i = 0; i < concurrentFrameCount; ++i) {
        // Initialize the ground matrix (first matrix in the buffer)
        const VkDeviceSize groundOffset = i * 8 * alignedUniformSize; // *8 for ground, player, collectible, NPC1, NPC2, NPC3, house, indoor
        memcpy(p + groundOffset, ident.constData(), 16 * sizeof(float));
        mUniformBufferInfo[i].buffer = mBuffer;
        mUniformBufferInfo[i].offset = groundOffset;
        mUniformBufferInfo[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the player matrix space (second matrix in the buffer)
        const VkDeviceSize playerOffset = groundOffset + alignedUniformSize;
        memcpy(p + playerOffset, ident.constData(), 16 * sizeof(float));
        mPlayerUniformBufferInfo[i].buffer = mBuffer;
        mPlayerUniformBufferInfo[i].offset = playerOffset;
        mPlayerUniformBufferInfo[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the collectible matrix space (third matrix in the buffer)
        const VkDeviceSize collectibleOffset = playerOffset + alignedUniformSize;
        memcpy(p + collectibleOffset, ident.constData(), 16 * sizeof(float));
        mCollectibleUniformBufferInfo[i].buffer = mBuffer;
        mCollectibleUniformBufferInfo[i].offset = collectibleOffset;
        mCollectibleUniformBufferInfo[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the NPC1 matrix space (fourth matrix in the buffer)
        const VkDeviceSize npc1Offset = collectibleOffset + alignedUniformSize;
        memcpy(p + npc1Offset, ident.constData(), 16 * sizeof(float));
        mNPCUniformBufferInfo1[i].buffer = mBuffer;
        mNPCUniformBufferInfo1[i].offset = npc1Offset;
        mNPCUniformBufferInfo1[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the NPC2 matrix space (fifth matrix in the buffer)
        const VkDeviceSize npc2Offset = npc1Offset + alignedUniformSize;
        memcpy(p + npc2Offset, ident.constData(), 16 * sizeof(float));
        mNPCUniformBufferInfo2[i].buffer = mBuffer;
        mNPCUniformBufferInfo2[i].offset = npc2Offset;
        mNPCUniformBufferInfo2[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the NPC3 matrix space (sixth matrix in the buffer)
        const VkDeviceSize npc3Offset = npc2Offset + alignedUniformSize;
        memcpy(p + npc3Offset, ident.constData(), 16 * sizeof(float));
        mNPCUniformBufferInfo3[i].buffer = mBuffer;
        mNPCUniformBufferInfo3[i].offset = npc3Offset;
        mNPCUniformBufferInfo3[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the house matrix space (seventh matrix in the buffer)
        const VkDeviceSize houseOffset = npc3Offset + alignedUniformSize;
        memcpy(p + houseOffset, ident.constData(), 16 * sizeof(float));
        mHouseUniformBufferInfo[i].buffer = mBuffer;
        mHouseUniformBufferInfo[i].offset = houseOffset;
        mHouseUniformBufferInfo[i].range = UNIFORM_DATA_SIZE;
        
        // Initialize the indoor scene matrix space (eighth matrix in the buffer)
        const VkDeviceSize indoorOffset = houseOffset + alignedUniformSize;
        memcpy(p + indoorOffset, ident.constData(), 16 * sizeof(float));
        mIndoorUniformBufferInfo[i].buffer = mBuffer;
        mIndoorUniformBufferInfo[i].offset = indoorOffset;
        mIndoorUniformBufferInfo[i].range = UNIFORM_DATA_SIZE;
    }
    
    mDeviceFunctions->vkUnmapMemory(logicalDevice, mBufferMemory);

    /********************************* Vertex layout: *********************************/
    //The size of each vertex to be passed to the shader
    VkVertexInputBindingDescription vertexBindingDesc = {
        0, // binding - has to match that in VkVertexInputAttributeDescription and startNextFrame()s m_devFuncs->vkCmdBindVertexBuffers
        8 * sizeof(float), // stride account for X, Y, Z, R, G, B, U, V (positions, colors, texture coords)
        VK_VERTEX_INPUT_RATE_VERTEX
    };

    /********************************* Shader bindings: *********************************/
    //Descritpion of the attributes used in the shader
    VkVertexInputAttributeDescription vertexAttrDesc[] = {
        { // position
            0, // location has to correspond to the layout(location = x) in the shader
            0, // binding
            VK_FORMAT_R32G32B32_SFLOAT,
            0
        },
        { // color
            1, // location has to correspond to the layout(location = x) in the shader
            0, // binding
            VK_FORMAT_R32G32B32_SFLOAT,
            3 * sizeof(float) // offset to account for X, Y, Z
        },
        { // texture coordinates
            2, // location has to correspond to the layout(location = x) in the shader
            0, // binding
            VK_FORMAT_R32G32_SFLOAT,
            6 * sizeof(float) // offset to account for X, Y, Z, R, G, B
        }
    };

    VkPipelineVertexInputStateCreateInfo vertexInputInfo;
    vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertexInputInfo.pNext = nullptr;
    vertexInputInfo.flags = 0;
    vertexInputInfo.vertexBindingDescriptionCount = 1;
    vertexInputInfo.pVertexBindingDescriptions = &vertexBindingDesc;
    vertexInputInfo.vertexAttributeDescriptionCount = 3;
    vertexInputInfo.pVertexAttributeDescriptions = vertexAttrDesc;
}
